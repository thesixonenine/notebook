=== 树的一些基本概念
image::7.09 树与二叉树的基本概念/树.png[]

- 结点: 图中一共 **8** 个结点.
- 结点的度: 结点的直接子结点数. 1 总共有 2 和 3 两个子结点, 所以 1 的度是 2
- 树的度: 所有结点中, 度最高的值就是树的度
- 树的路径长度: 结点之间相连的线段总数
- **带权路径长度**: 从根结点到指定结点的线段总数 乘以 指定结点的键值
- 树的带权路径长度: 将所有结点的**带权路径长度**求和
- 叶子结点: 没有子结点的结点 或者 度为 0 的结点. 图中的 4 5 7 8
- 分支结点: 除叶子结点外的其他结点 或者 度不为 0 的结点. 图中的 1 2 3 6
- 内部结点: 除了根结点和叶子结点的其他结点 或者 在分支结点的基础之上在去掉根结点. 图中的 2 3 6
- 父, 子, 兄弟结点: 都是相对而言的. 图中 1 是 2 3 的父结点, 4 5 是 2 的子结点, 7 8 是兄弟结点
- 层次(高度): 如图所示: 4 层. 若某结点在第 i 层, 则其子结点在第 i + 1 层


=== 二叉树(binary tree)

定义: 树中结点的**度不大于 2 **的**有序树**.

递归定义: 二叉树是一棵**空树**, 或者是一棵由 一个根结点 和 两棵互不相交的, 分别称作根的左子树和右子树组成的非空树且左子树和右子树又同样都是二叉树.

性质:

. 第 i 层上最多有 2 ^ (i - 1) 个结点(i ≥ 1)
. 层数(高度)为 k 最多有2 ^ k - 1个结点(k ≥ 1)
. 对于任何一棵非空的二叉树,如果叶子结点个数为n0, 度为2的结点个数为n2, 则有: n0 = n2 + 1

==== 二叉树的遍历

- 前序遍历: 先访问根结点, 再访问左子树, 然后访问右子树
- 中序遍历: 先访问左子树, 再访问根结点, 然后访问右子树
- 后序遍历: 先访问左子树, 再访问右子树, 然后访问根结点
- 层次遍历: 每一层从上到下, 从左到右遍历

==== 反向构造二叉树

已知二叉树的遍历序列, 求二叉树

==== 树转成二叉树

- 子结点 都是 左子树的结点
- 兄弟结点 都是 右子树的结点

实际做法如下:

- 将兄弟结点都连接起来
- 只保留结点与左一子结点的连接, 去除结点与其余子结点的连接
- 整理二叉树即可

==== 查找(排序)二叉树

**特点**

- 结点的左子树的所有结点都小于结点
- 结点的右子树的所有结点都大于结点

**插入结点**

1. 若该值的结点已存在, 则不再插入
2. 若查找二叉树为空树, 则以新结点为查找二叉树
3. 将要插入的结点键值与插入后的父结点键值相比较, 就能确定新结点是父结点的左子结点还是右子结点

**删除结点**

1. 若待删除的结点是叶子结点, 则直接删除
2. 若待删除的结点只有一个子结点, 则将这个子结点与待删除结点的父结点直接连接
3. 若待删除的结点p有两个子结点, 则在其左子树上, 用中序遍历寻找键值最大的结点s, 用结点s的值代替结点p的值, 然后删除结点s, 结点s必属于1,2情况之一

==== 最优二叉树(Huffman Tree)

用于哈夫曼编码(Huffman Coding)

特点: **树的带权路径长度**最短

给定权值, 求二叉树及其带权路径长度

==== 线索二叉树

由于二叉树中的叶子结点存在为空的情况, 所以可以用来指向前序遍历/中序遍历/后序遍历中的前一个或后一个结点

==== 平衡二叉树

- 任意结点的左右子树深度相差不超过1
- 每个结点的平衡度只能为-1, 0, 1

=== 图

- 无向图: 连线没有箭头
- 完全无相图: 连线没有箭头且任意两两结点都相连
- 有向图: 连线有箭头
- 完全有向图: 连线有箭头且任意两两结点都有两条有向线段互指

==== 图的存储

- 邻接矩阵: 结点总数n, 则矩阵为n x n. 有连线为1, 没有则为0
- 邻接表: 一张表(数组)存储所有结点, 每个结点存储该结点能到达的结点

==== 图的遍历

- 深度优先
- 广度优先

7.19
