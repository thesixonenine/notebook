== 线性表

n个具**有相同特性**的数据元素的**有限序列**.

=== 分类

- 顺序表示: 用一组地址连续的存储单元依次存储线性表的数据元素.
- 链式表示: 用一组任意的存储单元存储线性表中的数据元素

[NOTE]
链式表示的存储单元可以是连续的, 也可以是不连续的.
在表示数据元素之间的逻辑关系时, 除了存储其本身的信息之外, 还需存储一个指示其直接后继的信息(即直接后继的存储位置), 这两部分信息组成数据元素的存储映像,称为**结点**(node).
**结点**包括两个域: 存储数据元素信息的域称为**数据域**, 存储直接后继存储位置的域称为**指针域**. 指针域中存储的信息称为**指针**或链.

=== 结构特点

- 均匀性: 对于同一线性表的各数据元素必定具有相同的数据类型和长度
- 有序性: 各数据元素在线性表中的位置只取决于它们的序号

=== 链式表示的扩展

- 单链表
- 循环链表: 最后一个node的指针指向第一个元素
- 双向链表: 每个node都有两个指针, 分别指向前后node


.顺序存储与链式存储
[cols="^.^1,^.^1,^.^1,^.^1"]
|===
|性能类别 |性能项目 |顺序存储 |链式存储

.2+|空间性能
|存储密度
|=1,更优
|<1


|容量分配
|事先确定
|动态改变, 更优

.4+^|时间性能
|查询
|O(n/2)
|O(n/2)

|读取
|O(1), 更优
|O((n+1)/2), 最好是1, 最坏是n

|写入
|O(n/2), 最好是0, 最坏是n
|O(1), 更优

|删除
|O((n-1)/2)
|O(1), 更优
|===


=== 队列与栈

- 队列: 先进先出
- 栈: 先进后出

**循环队列**

把顺序队列首尾相连, 把存储队列元素的表从逻辑上看成一个环

- 队空条件: head = tail
- 队满条件: (tail + 1) % size = head

条件处理:

循环队列中, 由于**入队时尾指针向前追赶头指针**; *出队时头指针向前追赶尾指针*, 造成**队空和队满时头尾指针均相等**. 因此, 无法通过条件head==tail来判别队列是"空"还是"满".

两个办法解决:

. 设一布尔变量以区别队列的空和满
. 最后一个不存值, 判断 (tail + 1) % size = head

[caption="例1: "]
.出栈顺序
====
元素按照a, b, c的顺序入栈, 请尝试写出所有可能的出栈序列.

答: **cba**, **abc**, **bac**
====

[caption="例2: "]
.队列和栈
====
输出受限的双端队列是指元素可以从队列的两端输入, 但只能从队列的一端输出.
如下图所示, 若有e1, e2, e3, e4依次进入输出受限的双端队列, 则得不到输出序列()

**A.** e4,e3,e2,e1 **B.** e4,e2,e1,e3 **C.**. e4,e3,e1,e2 **D.** e4,e2,e3,e1

答: **D**. 因为是**e1**到**e4**的顺序从双端输入且**e4**先出, 则肯定是全部输入完后再考虑输出, 且**e2**肯定在**e1**的左边或者右边,
又因为只能从一边输出, 则输出顺序肯定是**e2,e1**或者**e1,e2**.
====

=== 广义表

广义表是n(n≥0)个元素a1, a2, ... ai, ... an的有限序列.

. ai是一个**原子**或者是一个**广义表**
. 广义表记作: Ls=(a1, a2, ... ai, ... an)
. Ls是广义表的名字, n是它的长度
. 若ai是广义表, 则称ai为Ls的子表
. 若广义表Ls非空(n≥1), 则**a1是Ls的表头**, **其余元素组成的表(a2, a3, ... an)称为Ls的表尾**
. 表的**深度**是指表展开后所含括号的层数
. 广义表是递归定义的

==== 广义表的两个特殊的基本运算
- 取表头head(Ls)
- 取表尾tail(Ls)

[caption="例3: "]
.广义表的长度与深度
====
有广义表Ls1=(a, (b, c), (d, e)), 则其长度为? 深度为?

答: 长度为**3**, 深度为**2**.
====

[caption="例4: "]
.广义表取出元素
====
有广义表Ls1=(a, (b, c), (d, e)) , 要将b元素取出, 操作为?

答: **head(head(tail(Ls1)))**.
====
